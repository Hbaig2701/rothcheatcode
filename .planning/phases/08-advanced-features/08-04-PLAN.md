---
phase: 08-advanced-features
plan: 04
type: execute
wave: 2
depends_on: ["08-01", "08-02", "08-03"]
files_modified:
  - supabase/migrations/005_audit_log.sql
  - lib/audit/types.ts
  - lib/audit/log.ts
  - lib/audit/hash.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Audit log table is append-only (no UPDATE/DELETE)"
    - "RLS restricts users to their own audit logs"
    - "Input hash enables cache deduplication"
    - "Logging is fire-and-forget (non-blocking)"
  artifacts:
    - path: "supabase/migrations/005_audit_log.sql"
      provides: "Append-only audit log schema with immutability trigger"
      contains: "CREATE TABLE audit.calculation_log"
    - path: "lib/audit/types.ts"
      provides: "TypeScript types for audit log entries"
      exports: ["AuditLogEntry", "AuditLogInsert"]
    - path: "lib/audit/log.ts"
      provides: "Audit logging functions"
      exports: ["logCalculation", "getCalculationHistory"]
    - path: "lib/audit/hash.ts"
      provides: "Input hashing for deduplication"
      exports: ["hashClientInput"]
  key_links:
    - from: "supabase/migrations/005_audit_log.sql"
      to: "Database immutability"
      via: "PostgreSQL trigger prevents UPDATE/DELETE"
      pattern: "BEFORE UPDATE OR DELETE"
    - from: "lib/audit/log.ts"
      to: "supabase/client"
      via: "Supabase INSERT"
      pattern: "supabase.*from.*insert"
---

<objective>
Implement compliance audit logging with an append-only PostgreSQL table and TypeScript integration for recording all calculation runs.

Purpose: Provide an immutable audit trail for compliance and debugging, recording client snapshots and calculation results with timestamps.

Output: Database migration for audit schema, TypeScript types, and logging functions with fire-and-forget insertion.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-advanced-features/08-RESEARCH.md

# Existing database patterns
@supabase/migrations/004_projections.sql
@lib/types/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create audit log database migration</name>
  <files>supabase/migrations/005_audit_log.sql</files>
  <action>
Create `supabase/migrations/005_audit_log.sql`:

```sql
-- Audit log schema for compliance tracking
-- Append-only table with trigger-enforced immutability

-- Create audit schema
CREATE SCHEMA IF NOT EXISTS audit;

-- Calculation audit log table
CREATE TABLE IF NOT EXISTS audit.calculation_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- User context
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  client_id UUID NOT NULL REFERENCES clients(id) ON DELETE CASCADE,

  -- Calculation inputs (snapshot)
  input_hash TEXT NOT NULL,              -- SHA256 of client data for deduplication
  client_snapshot JSONB NOT NULL,        -- Full client data at time of calculation

  -- Strategy used
  strategy TEXT NOT NULL,

  -- Calculation outputs (summary)
  break_even_age INTEGER,
  total_tax_savings BIGINT NOT NULL,
  heir_benefit BIGINT NOT NULL,

  -- Final wealth comparison (cents)
  baseline_final_wealth BIGINT NOT NULL,
  blueprint_final_wealth BIGINT NOT NULL,

  -- Performance tracking
  calculation_ms INTEGER,

  -- Version tracking
  engine_version TEXT NOT NULL DEFAULT '1.0.0'
);

-- Prevent updates and deletes (immutability enforcement)
CREATE OR REPLACE FUNCTION audit.prevent_modification()
RETURNS TRIGGER AS $$
BEGIN
  RAISE EXCEPTION 'Audit logs are immutable - cannot modify or delete';
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER prevent_audit_update
  BEFORE UPDATE OR DELETE ON audit.calculation_log
  FOR EACH ROW EXECUTE FUNCTION audit.prevent_modification();

-- Row Level Security
ALTER TABLE audit.calculation_log ENABLE ROW LEVEL SECURITY;

-- Users can only view their own audit logs
CREATE POLICY "Users view own audit logs"
  ON audit.calculation_log FOR SELECT
  USING (auth.uid() = user_id);

-- Users can only insert their own audit logs
CREATE POLICY "Users insert own audit logs"
  ON audit.calculation_log FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- No UPDATE or DELETE policies - trigger prevents anyway

-- Indexes for efficient queries
CREATE INDEX IF NOT EXISTS idx_audit_log_client_created
  ON audit.calculation_log(client_id, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_audit_log_user_created
  ON audit.calculation_log(user_id, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_audit_log_input_hash
  ON audit.calculation_log(input_hash);

-- Comment for documentation
COMMENT ON TABLE audit.calculation_log IS
  'Immutable audit log of all calculation runs. Cannot be modified after insertion.';
```

**To apply migration:**
Run via Supabase dashboard SQL editor or:
```bash
npx supabase db push
```
  </action>
  <verify>
Migration file exists at `supabase/migrations/005_audit_log.sql`.
SQL syntax is valid (no parse errors).
Trigger name `prevent_audit_update` is unique.
  </verify>
  <done>
Audit log schema created with append-only enforcement via PostgreSQL trigger. RLS restricts access to own records.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create audit TypeScript types and logging functions</name>
  <files>
    lib/audit/types.ts
    lib/audit/hash.ts
    lib/audit/log.ts
    lib/audit/index.ts
  </files>
  <action>
Create `lib/audit/` directory with four files:

**lib/audit/types.ts** - TypeScript types:
```typescript
import type { Client } from '@/lib/types/client';

/**
 * Audit log entry as stored in database
 * All monetary values in cents
 */
export interface AuditLogEntry {
  id: string;
  created_at: string;
  user_id: string;
  client_id: string;
  input_hash: string;
  client_snapshot: Client;
  strategy: string;
  break_even_age: number | null;
  total_tax_savings: number;
  heir_benefit: number;
  baseline_final_wealth: number;
  blueprint_final_wealth: number;
  calculation_ms: number | null;
  engine_version: string;
}

/**
 * Insert payload for new audit log entry
 * Omit server-generated fields
 */
export type AuditLogInsert = Omit<AuditLogEntry, 'id' | 'created_at'>;

/**
 * Query result from getCalculationHistory
 */
export interface AuditLogSummary {
  id: string;
  created_at: string;
  strategy: string;
  break_even_age: number | null;
  total_tax_savings: number;
  blueprint_final_wealth: number;
  engine_version: string;
}
```

**lib/audit/hash.ts** - Input hashing:
```typescript
import type { Client } from '@/lib/types/client';

/**
 * Create SHA-256 hash of client input for cache deduplication
 * Uses sorted keys to ensure consistent hashing regardless of object order
 */
export async function hashClientInput(client: Client): Promise<string> {
  // Extract only calculation-relevant fields (exclude metadata)
  const relevantFields = {
    date_of_birth: client.date_of_birth,
    spouse_dob: client.spouse_dob,
    filing_status: client.filing_status,
    state: client.state,
    life_expectancy: client.life_expectancy,
    traditional_ira: client.traditional_ira,
    roth_ira: client.roth_ira,
    taxable_accounts: client.taxable_accounts,
    other_retirement: client.other_retirement,
    federal_bracket: client.federal_bracket,
    state_tax_rate: client.state_tax_rate,
    include_niit: client.include_niit,
    include_aca: client.include_aca,
    ss_self: client.ss_self,
    ss_spouse: client.ss_spouse,
    pension: client.pension,
    other_income: client.other_income,
    ss_start_age: client.ss_start_age,
    strategy: client.strategy,
    start_age: client.start_age,
    end_age: client.end_age,
    tax_payment_source: client.tax_payment_source,
    growth_rate: client.growth_rate,
    inflation_rate: client.inflation_rate,
    heir_bracket: client.heir_bracket,
    projection_years: client.projection_years,
  };

  // Sort keys for consistent ordering
  const sortedJson = JSON.stringify(relevantFields, Object.keys(relevantFields).sort());

  // Use Web Crypto API (works in browser and Edge runtime)
  const encoder = new TextEncoder();
  const data = encoder.encode(sortedJson);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);

  // Convert to hex string
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}
```

**lib/audit/log.ts** - Logging functions:
```typescript
import type { SupabaseClient } from '@supabase/supabase-js';
import type { Client } from '@/lib/types/client';
import type { SimulationResult } from '@/lib/calculations/types';
import type { AuditLogInsert, AuditLogSummary } from './types';
import { hashClientInput } from './hash';

const ENGINE_VERSION = '1.0.0';

/**
 * Log a calculation run to the audit table
 * Fire-and-forget: Does not await result to avoid blocking UI
 *
 * @param supabase - Supabase client instance
 * @param client - Client data at time of calculation
 * @param result - Simulation result
 * @param durationMs - Calculation time in milliseconds
 */
export function logCalculation(
  supabase: SupabaseClient,
  client: Client,
  result: SimulationResult,
  durationMs: number
): void {
  // Fire-and-forget: Don't await to avoid blocking
  (async () => {
    try {
      const inputHash = await hashClientInput(client);

      const lastBaseline = result.baseline[result.baseline.length - 1];
      const lastBlueprint = result.blueprint[result.blueprint.length - 1];

      const entry: AuditLogInsert = {
        user_id: client.user_id,
        client_id: client.id,
        input_hash: inputHash,
        client_snapshot: client,
        strategy: client.strategy,
        break_even_age: result.breakEvenAge,
        total_tax_savings: result.totalTaxSavings,
        heir_benefit: result.heirBenefit,
        baseline_final_wealth: lastBaseline.netWorth,
        blueprint_final_wealth: lastBlueprint.netWorth,
        calculation_ms: Math.round(durationMs),
        engine_version: ENGINE_VERSION,
      };

      // Insert to audit schema (note: Supabase client needs schema prefix)
      const { error } = await supabase
        .schema('audit')
        .from('calculation_log')
        .insert(entry);

      if (error) {
        // Log error but don't throw - audit failure shouldn't break calculations
        console.error('[Audit] Failed to log calculation:', error.message);
      }
    } catch (err) {
      console.error('[Audit] Error in audit logging:', err);
    }
  })();
}

/**
 * Get calculation history for a client
 * Returns most recent N entries (summary only)
 */
export async function getCalculationHistory(
  supabase: SupabaseClient,
  clientId: string,
  limit = 10
): Promise<AuditLogSummary[]> {
  const { data, error } = await supabase
    .schema('audit')
    .from('calculation_log')
    .select(`
      id,
      created_at,
      strategy,
      break_even_age,
      total_tax_savings,
      blueprint_final_wealth,
      engine_version
    `)
    .eq('client_id', clientId)
    .order('created_at', { ascending: false })
    .limit(limit);

  if (error) {
    console.error('[Audit] Failed to fetch history:', error.message);
    return [];
  }

  return data ?? [];
}

/**
 * Check if a calculation with the same inputs already exists
 * Uses input_hash for deduplication
 */
export async function hasExistingCalculation(
  supabase: SupabaseClient,
  client: Client
): Promise<boolean> {
  const inputHash = await hashClientInput(client);

  const { data, error } = await supabase
    .schema('audit')
    .from('calculation_log')
    .select('id')
    .eq('client_id', client.id)
    .eq('input_hash', inputHash)
    .limit(1);

  if (error) {
    console.error('[Audit] Failed to check existing:', error.message);
    return false;
  }

  return (data?.length ?? 0) > 0;
}
```

**lib/audit/index.ts** - Barrel export:
```typescript
export * from './types';
export * from './hash';
export * from './log';
```
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm types compile.
Verify `lib/audit/index.ts` exports all modules.
Check that `logCalculation` is non-awaited (fire-and-forget).
  </verify>
  <done>
Audit TypeScript integration complete with types, hashing function, and fire-and-forget logging. History retrieval function available for UI display.
  </done>
</task>

</tasks>

<verification>
1. Migration file `005_audit_log.sql` exists and has valid SQL
2. `npx tsc --noEmit` compiles without errors
3. `audit.prevent_modification()` trigger prevents UPDATE/DELETE
4. RLS policies restrict to own user_id
5. `logCalculation` is fire-and-forget (no await in caller)
6. `hashClientInput` uses crypto.subtle.digest for SHA-256
7. All audit exports available from `lib/audit`
</verification>

<success_criteria>
- Audit schema created with immutable calculation_log table
- PostgreSQL trigger raises exception on UPDATE/DELETE attempts
- RLS allows SELECT/INSERT only for own user_id records
- TypeScript types match database schema
- Input hashing uses SHA-256 via Web Crypto API
- Logging is non-blocking (fire-and-forget pattern)
- History retrieval returns summary records ordered by created_at DESC
</success_criteria>

<output>
After completion, create `.planning/phases/08-advanced-features/08-04-SUMMARY.md`
</output>
