---
phase: 04-calculation-engine-core
plan: 05
type: execute
wave: 4
depends_on: [04-04]
files_modified:
  - supabase/migrations/004_projections.sql
  - lib/types/projection.ts
  - app/api/clients/[id]/projections/route.ts
autonomous: true

must_haves:
  truths:
    - "Projections table exists in database with proper schema"
    - "API endpoint accepts client ID and returns projection results"
    - "Projection data is stored for later retrieval"
    - "API validates client ownership before running projection"
  artifacts:
    - path: "supabase/migrations/004_projections.sql"
      provides: "Database schema for projection storage"
      contains: "CREATE TABLE projections"
    - path: "lib/types/projection.ts"
      provides: "Projection type definitions for API"
      exports: ["Projection", "ProjectionInsert"]
    - path: "app/api/clients/[id]/projections/route.ts"
      provides: "Projection API endpoint"
      exports: ["GET", "POST"]
  key_links:
    - from: "app/api/clients/[id]/projections/route.ts"
      to: "lib/calculations/index.ts"
      via: "import runSimulation"
      pattern: "import.*runSimulation.*from"
    - from: "app/api/clients/[id]/projections/route.ts"
      to: "lib/supabase/server.ts"
      via: "createClient for DB access"
      pattern: "import.*createClient.*from"
---

<objective>
Create the API endpoint and database storage for projection results.

Purpose: Enable the UI to request projections for a client and retrieve stored results.
Output: REST API endpoint that runs simulations and stores/retrieves projection data.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-calculation-engine-core/04-RESEARCH.md
@.planning/phases/04-calculation-engine-core/04-04-SUMMARY.md

@lib/calculations/index.ts
@lib/types/client.ts
@app/api/clients/[id]/route.ts
@lib/supabase/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database migration for projections table</name>
  <files>
    supabase/migrations/004_projections.sql
  </files>
  <action>
Create `supabase/migrations/004_projections.sql`:

```sql
-- Projections table for storing simulation results
-- Stores summary data and full year-by-year results as JSONB

CREATE TABLE IF NOT EXISTS projections (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  client_id UUID NOT NULL REFERENCES clients(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- Input snapshot (to detect if client data changed)
  input_hash TEXT NOT NULL,

  -- Summary metrics
  break_even_age INTEGER,
  total_tax_savings BIGINT NOT NULL,  -- In cents
  heir_benefit BIGINT NOT NULL,       -- In cents

  -- Baseline scenario final values
  baseline_final_traditional BIGINT NOT NULL,
  baseline_final_roth BIGINT NOT NULL,
  baseline_final_taxable BIGINT NOT NULL,
  baseline_final_net_worth BIGINT NOT NULL,

  -- Blueprint scenario final values
  blueprint_final_traditional BIGINT NOT NULL,
  blueprint_final_roth BIGINT NOT NULL,
  blueprint_final_taxable BIGINT NOT NULL,
  blueprint_final_net_worth BIGINT NOT NULL,

  -- Full year-by-year data (JSONB for flexibility)
  baseline_years JSONB NOT NULL,
  blueprint_years JSONB NOT NULL,

  -- Strategy used
  strategy TEXT NOT NULL,
  projection_years INTEGER NOT NULL
);

-- Index for fast lookup by client
CREATE INDEX IF NOT EXISTS idx_projections_client_id ON projections(client_id);

-- Index for finding latest projection per client
CREATE INDEX IF NOT EXISTS idx_projections_created_at ON projections(client_id, created_at DESC);

-- Enable RLS
ALTER TABLE projections ENABLE ROW LEVEL SECURITY;

-- RLS policies: Users can only access their own projections
CREATE POLICY "Users can view own projections"
  ON projections FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can create own projections"
  ON projections FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own projections"
  ON projections FOR DELETE
  USING (auth.uid() = user_id);

-- Comment on table
COMMENT ON TABLE projections IS 'Stores Roth conversion simulation results for clients';
COMMENT ON COLUMN projections.input_hash IS 'Hash of client input data to detect changes';
COMMENT ON COLUMN projections.baseline_years IS 'Year-by-year results for no-conversion scenario';
COMMENT ON COLUMN projections.blueprint_years IS 'Year-by-year results for conversion scenario';
```
  </action>
  <verify>
Verify SQL syntax: The migration should be valid PostgreSQL.
Check migration filename follows existing pattern (001, 002, 003... -> 004).
  </verify>
  <done>
Projections table created with proper schema, indexes, and RLS policies.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create projection types and API route</name>
  <files>
    lib/types/projection.ts
    app/api/clients/[id]/projections/route.ts
  </files>
  <action>
Create `lib/types/projection.ts`:

```typescript
import { YearlyResult } from '@/lib/calculations';

/**
 * Projection record from database
 */
export interface Projection {
  id: string;
  client_id: string;
  user_id: string;
  created_at: string;
  input_hash: string;

  // Summary metrics
  break_even_age: number | null;
  total_tax_savings: number;  // In cents
  heir_benefit: number;       // In cents

  // Baseline final values
  baseline_final_traditional: number;
  baseline_final_roth: number;
  baseline_final_taxable: number;
  baseline_final_net_worth: number;

  // Blueprint final values
  blueprint_final_traditional: number;
  blueprint_final_roth: number;
  blueprint_final_taxable: number;
  blueprint_final_net_worth: number;

  // Full year data
  baseline_years: YearlyResult[];
  blueprint_years: YearlyResult[];

  strategy: string;
  projection_years: number;
}

/**
 * For inserting new projection
 */
export type ProjectionInsert = Omit<Projection, 'id' | 'created_at'>;

/**
 * API response for projection endpoint
 */
export interface ProjectionResponse {
  projection: Projection;
  cached: boolean;  // True if returned existing projection
}
```

Create `app/api/clients/[id]/projections/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { runSimulation, createSimulationInput, SimulationResult } from '@/lib/calculations';
import { Client } from '@/lib/types/client';
import { Projection, ProjectionInsert, ProjectionResponse } from '@/lib/types/projection';
import crypto from 'crypto';

/**
 * Generate hash of client input data to detect changes
 */
function generateInputHash(client: Client): string {
  const relevantFields = {
    traditional_ira: client.traditional_ira,
    roth_ira: client.roth_ira,
    taxable_accounts: client.taxable_accounts,
    other_retirement: client.other_retirement,
    date_of_birth: client.date_of_birth,
    spouse_dob: client.spouse_dob,
    filing_status: client.filing_status,
    state: client.state,
    federal_bracket: client.federal_bracket,
    strategy: client.strategy,
    start_age: client.start_age,
    end_age: client.end_age,
    growth_rate: client.growth_rate,
    inflation_rate: client.inflation_rate,
    projection_years: client.projection_years,
    // ... other relevant fields
  };
  return crypto.createHash('sha256').update(JSON.stringify(relevantFields)).digest('hex');
}

/**
 * Convert simulation result to projection insert
 */
function simulationToProjection(
  clientId: string,
  userId: string,
  client: Client,
  result: SimulationResult,
  inputHash: string
): ProjectionInsert {
  const lastBaseline = result.baseline[result.baseline.length - 1];
  const lastBlueprint = result.blueprint[result.blueprint.length - 1];

  return {
    client_id: clientId,
    user_id: userId,
    input_hash: inputHash,
    break_even_age: result.breakEvenAge,
    total_tax_savings: result.totalTaxSavings,
    heir_benefit: result.heirBenefit,
    baseline_final_traditional: lastBaseline.traditionalBalance,
    baseline_final_roth: lastBaseline.rothBalance,
    baseline_final_taxable: lastBaseline.taxableBalance,
    baseline_final_net_worth: lastBaseline.netWorth,
    blueprint_final_traditional: lastBlueprint.traditionalBalance,
    blueprint_final_roth: lastBlueprint.rothBalance,
    blueprint_final_taxable: lastBlueprint.taxableBalance,
    blueprint_final_net_worth: lastBlueprint.netWorth,
    baseline_years: result.baseline,
    blueprint_years: result.blueprint,
    strategy: client.strategy,
    projection_years: client.projection_years
  };
}

/**
 * GET /api/clients/[id]/projections
 * Returns the latest projection for a client, running new simulation if data changed
 */
export async function GET(
  request: NextRequest,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const { id: clientId } = await context.params;
    const supabase = await createClient();

    // Verify auth
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Fetch client data
    const { data: client, error: clientError } = await supabase
      .from('clients')
      .select('*')
      .eq('id', clientId)
      .single();

    if (clientError) {
      if (clientError.code === 'PGRST116') {
        return NextResponse.json({ error: 'Client not found' }, { status: 404 });
      }
      throw clientError;
    }

    // Generate input hash to check if data changed
    const inputHash = generateInputHash(client as Client);

    // Check for existing projection with matching hash
    const { data: existingProjection } = await supabase
      .from('projections')
      .select('*')
      .eq('client_id', clientId)
      .eq('input_hash', inputHash)
      .order('created_at', { ascending: false })
      .limit(1)
      .single();

    if (existingProjection) {
      // Return cached projection
      return NextResponse.json({
        projection: existingProjection,
        cached: true
      } as ProjectionResponse);
    }

    // Run new simulation
    const simulationInput = createSimulationInput(client as Client);
    const result = runSimulation(simulationInput);

    // Store projection
    const projectionInsert = simulationToProjection(
      clientId,
      user.id,
      client as Client,
      result,
      inputHash
    );

    const { data: newProjection, error: insertError } = await supabase
      .from('projections')
      .insert(projectionInsert)
      .select()
      .single();

    if (insertError) {
      throw insertError;
    }

    return NextResponse.json({
      projection: newProjection,
      cached: false
    } as ProjectionResponse);

  } catch (error) {
    console.error('Projection error:', error);
    return NextResponse.json(
      { error: 'Failed to generate projection' },
      { status: 500 }
    );
  }
}

/**
 * POST /api/clients/[id]/projections
 * Force recalculation even if cached projection exists
 */
export async function POST(
  request: NextRequest,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const { id: clientId } = await context.params;
    const supabase = await createClient();

    // Verify auth
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Fetch client data
    const { data: client, error: clientError } = await supabase
      .from('clients')
      .select('*')
      .eq('id', clientId)
      .single();

    if (clientError) {
      if (clientError.code === 'PGRST116') {
        return NextResponse.json({ error: 'Client not found' }, { status: 404 });
      }
      throw clientError;
    }

    // Generate input hash
    const inputHash = generateInputHash(client as Client);

    // Run new simulation (force recalculate)
    const simulationInput = createSimulationInput(client as Client);
    const result = runSimulation(simulationInput);

    // Store projection
    const projectionInsert = simulationToProjection(
      clientId,
      user.id,
      client as Client,
      result,
      inputHash
    );

    const { data: newProjection, error: insertError } = await supabase
      .from('projections')
      .insert(projectionInsert)
      .select()
      .single();

    if (insertError) {
      throw insertError;
    }

    return NextResponse.json({
      projection: newProjection,
      cached: false
    } as ProjectionResponse);

  } catch (error) {
    console.error('Projection error:', error);
    return NextResponse.json(
      { error: 'Failed to generate projection' },
      { status: 500 }
    );
  }
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` - should compile.
Verify route structure matches Next.js 15 pattern (async params).
Check that RLS policies will allow the API operations.
  </verify>
  <done>
Projection types and API route complete. GET returns cached or new projection. POST forces recalculation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Apply migration and verify API</name>
  <files>
    (none - verification task)
  </files>
  <action>
1. Run the migration against Supabase:
   ```bash
   npx supabase db push
   ```
   Or if using remote:
   ```bash
   npx supabase db push --linked
   ```

2. Verify the migration applied:
   - Check Supabase dashboard for `projections` table
   - Verify RLS policies are enabled

3. Test API endpoint works by checking TypeScript compilation:
   ```bash
   npx tsc --noEmit
   ```

4. The full integration test will happen in Phase 05 when the UI consumes this API.

Note: Actual API testing should happen on the deployed Vercel instance per CLAUDE.md instructions.
  </action>
  <verify>
Migration applies without errors.
`npx tsc --noEmit` passes.
Projections table visible in Supabase dashboard.
  </verify>
  <done>
Database migration applied. API route ready for integration with frontend in Phase 05.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` passes
2. Migration file exists at supabase/migrations/004_projections.sql
3. Projection types exported from lib/types/projection.ts
4. API route handles GET (with caching) and POST (force recalc)
5. RLS policies restrict access to projection owner
</verification>

<success_criteria>
- Projections table has proper schema with JSONB for year data
- Input hash enables smart caching (only recalculate on data change)
- API validates user owns the client before running projection
- GET returns cached projection if data unchanged
- POST forces fresh calculation
- All monetary values stored in cents (BIGINT)
</success_criteria>

<output>
After completion, create `.planning/phases/04-calculation-engine-core/04-05-SUMMARY.md`
</output>
