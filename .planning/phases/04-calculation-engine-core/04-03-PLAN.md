---
phase: 04-calculation-engine-core
plan: 03
type: execute
wave: 2
depends_on: [04-01]
files_modified:
  - lib/calculations/modules/social-security.ts
  - lib/calculations/modules/irmaa.ts
  - lib/calculations/modules/aca.ts
  - lib/calculations/modules/inflation.ts
autonomous: true

must_haves:
  truths:
    - "Social Security taxation correctly calculates 0%, 50%, or 85% taxable based on provisional income"
    - "IRMAA returns correct surcharge tier based on MAGI and filing status"
    - "ACA subsidy cliff detection works at 400% FPL threshold"
    - "Inflation adjustment compounds correctly over multiple years"
  artifacts:
    - path: "lib/calculations/modules/social-security.ts"
      provides: "Social Security taxable amount calculation"
      exports: ["calculateSSTaxableAmount"]
    - path: "lib/calculations/modules/irmaa.ts"
      provides: "Medicare IRMAA surcharge calculation"
      exports: ["calculateIRMAA"]
    - path: "lib/calculations/modules/aca.ts"
      provides: "ACA subsidy cliff analysis"
      exports: ["checkACACliff", "calculateACAImpact"]
    - path: "lib/calculations/modules/inflation.ts"
      provides: "Inflation adjustment utilities"
      exports: ["adjustForInflation", "getInflationFactor"]
  key_links:
    - from: "lib/calculations/modules/irmaa.ts"
      to: "lib/data/irmaa-brackets.ts"
      via: "import IRMAA_TIERS_2026"
      pattern: "import.*IRMAA_TIERS_2026"
    - from: "lib/calculations/modules/aca.ts"
      to: "lib/data/federal-poverty.ts"
      via: "import getACASubsidyCutoff"
      pattern: "import.*getACASubsidyCutoff"
---

<objective>
Build income-related and Medicare calculation modules: Social Security taxation, IRMAA, ACA subsidies, and inflation.

Purpose: These modules handle the "tax torpedo" (SS taxation), Medicare premium surcharges, and healthcare subsidy cliffs that significantly impact Roth conversion decisions.
Output: Four pure function modules for income-based calculations and inflation adjustments.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-calculation-engine-core/04-RESEARCH.md
@.planning/phases/04-calculation-engine-core/04-01-SUMMARY.md

@lib/calculations/types.ts
@lib/data/irmaa-brackets.ts
@lib/data/federal-poverty.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Social Security taxation module</name>
  <files>
    lib/calculations/modules/social-security.ts
  </files>
  <action>
Create `lib/calculations/modules/social-security.ts`:
- Import `SSTaxInput`, `SSTaxResult` from `../types`

Implement `calculateSSTaxableAmount(input: SSTaxInput): SSTaxResult`:

The "tax torpedo" calculation - each $1 of other income can make up to $0.85 of SS benefits taxable.

Algorithm (from IRS Publication 915):
```typescript
export function calculateSSTaxableAmount(input: SSTaxInput): SSTaxResult {
  // Step 1: Calculate provisional income
  // Provisional = AGI (excluding SS) + tax-exempt interest + 50% of SS benefits
  const provisionalIncome =
    input.otherIncome +
    input.taxExemptInterest +
    Math.round(input.ssBenefits / 2);

  // Step 2: Determine thresholds based on filing status
  // NOTE: These thresholds have NOT been inflation-adjusted since 1984/1993
  const thresholds = input.filingStatus === 'married_filing_jointly'
    ? { lower: 3200000, upper: 4400000 }  // $32,000 / $44,000
    : input.filingStatus === 'married_filing_separately'
    ? { lower: 0, upper: 0 }  // MFS: 85% taxable from $0 if living together
    : { lower: 2500000, upper: 3400000 }; // Single, HoH: $25,000 / $34,000

  // Step 3: Calculate taxable amount based on provisional income

  // Below lower threshold: 0% taxable
  if (provisionalIncome <= thresholds.lower) {
    return { taxableAmount: 0, taxablePercent: 0, provisionalIncome };
  }

  // Between lower and upper: up to 50% taxable
  if (provisionalIncome <= thresholds.upper) {
    const excess = provisionalIncome - thresholds.lower;
    const taxable = Math.min(
      Math.round(excess * 0.5),
      Math.round(input.ssBenefits * 0.5)
    );
    return { taxableAmount: taxable, taxablePercent: 50, provisionalIncome };
  }

  // Above upper threshold: up to 85% taxable
  // Formula: 85% of excess over upper + lesser of (50% of SS or base amount)
  const baseAmount = input.filingStatus === 'married_filing_jointly' ? 600000 : 450000; // $6,000 / $4,500
  const fiftyPercentOfSS = Math.round(input.ssBenefits * 0.5);
  const lesserAmount = Math.min(baseAmount, fiftyPercentOfSS);

  const excess85 = provisionalIncome - thresholds.upper;
  const fromExcess = Math.round(excess85 * 0.85);

  const taxable = Math.min(
    fromExcess + lesserAmount,
    Math.round(input.ssBenefits * 0.85)  // Cap at 85% of benefits
  );

  return { taxableAmount: taxable, taxablePercent: 85, provisionalIncome };
}
```

Add JSDoc comment explaining the "tax torpedo" effect:
- In the 50-85% transition zone, effective marginal rate can exceed 100%
- Each $1 of additional income can increase AGI by $1.85 (the $1 + $0.85 of now-taxable SS)
  </action>
  <verify>
Run `npx tsc --noEmit` - should compile.

Test cases:
1. Married, $30,000 other income, $24,000 SS benefits:
   - Provisional = $30,000 + $12,000 = $42,000
   - Between $32k-$44k thresholds = 50% zone
   - Excess over $32k = $10,000, taxable = min($5,000, $12,000) = $5,000

2. Single, $50,000 other income, $20,000 SS benefits:
   - Provisional = $50,000 + $10,000 = $60,000
   - Above $34k = 85% zone
   - Should return taxable near 85% of benefits ($17,000)
  </verify>
  <done>
Social Security taxation module correctly implements the 0/50/85% taxable rules. Handles the "tax torpedo" effect in transition zones.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create IRMAA calculation module</name>
  <files>
    lib/calculations/modules/irmaa.ts
  </files>
  <action>
Create `lib/calculations/modules/irmaa.ts`:
- Import `IRMAAInput`, `IRMAAResult` from `../types`
- Import `IRMAA_TIERS_2026`, `getIRMAATier` from `@/lib/data/irmaa-brackets`

Implement `calculateIRMAA(input: IRMAAInput): IRMAAResult`:

CRITICAL: IRMAA uses CLIFF thresholds, not gradual increases. Being $1 over triggers full surcharge.

```typescript
export function calculateIRMAA(input: IRMAAInput): IRMAAResult {
  const isJoint = input.filingStatus === 'married_filing_jointly';

  // Find the tier this MAGI falls into (from highest to lowest)
  for (let i = IRMAA_TIERS_2026.length - 1; i >= 0; i--) {
    const tier = IRMAA_TIERS_2026[i];
    const lowerThreshold = isJoint ? tier.jointLower : tier.singleLower;

    // IMPORTANT: Use >= for cliff comparison (at or above threshold triggers tier)
    if (input.magi >= lowerThreshold) {
      const standardPartB = IRMAA_TIERS_2026[0].partBMonthly;
      const monthlyPartD = input.hasPartD ? tier.partDMonthly : 0;

      // Annual surcharge = (Part B premium - standard) + Part D surcharge, times 12
      const annualSurcharge = ((tier.partBMonthly - standardPartB) + monthlyPartD) * 12;

      return {
        tier: i,
        monthlyPartB: tier.partBMonthly,
        monthlyPartD,
        annualSurcharge
      };
    }
  }

  // Should never reach here - tier 0 has lowerThreshold of 0
  return {
    tier: 0,
    monthlyPartB: IRMAA_TIERS_2026[0].partBMonthly,
    monthlyPartD: 0,
    annualSurcharge: 0
  };
}
```

Add helper `isNearIRMAACliff(magi: number, isJoint: boolean, margin: number = 500000): { nearCliff: boolean, nextThreshold: number, amountToCliff: number }`:
- Returns true if MAGI is within $5,000 (default) of next IRMAA tier
- Used by conversion optimizer to avoid pushing client over cliff

Add JSDoc warning:
- IRMAA is based on MAGI from 2 years prior (uses income from tax return filed 2 years ago)
- Note this in the input documentation
  </action>
  <verify>
Run `npx tsc --noEmit` - should compile.

Test cases (2026 thresholds from research):
1. Single, MAGI $108,000 (below $109,000) - Tier 0, no surcharge
2. Single, MAGI $110,000 (above $109,000) - Tier 1, surcharge applies
3. Joint, MAGI $218,001 - Tier 1 (just over $218,000 threshold)
4. Cliff detection: $215,000 joint should flag "near cliff" to $218,000
  </verify>
  <done>
IRMAA module correctly implements cliff-based tier determination. Includes helper for conversion optimization to avoid cliffs.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create ACA and inflation modules</name>
  <files>
    lib/calculations/modules/aca.ts
    lib/calculations/modules/inflation.ts
  </files>
  <action>
Create `lib/calculations/modules/aca.ts`:
- Import `getFPL`, `getACASubsidyCutoff` from `@/lib/data/federal-poverty`

Define types:
```typescript
interface ACAInput {
  magi: number;              // In cents
  householdSize: number;     // Typically 1 or 2 (single or married)
  state: string;             // For AK/HI different FPL
  age: number;               // Under 65 only
}

interface ACAResult {
  affectsACA: boolean;       // True if under 65
  atSubsidyCliff: boolean;   // True if above 400% FPL
  subsidyLost: boolean;      // True if conversion pushed over cliff
  fplPercent: number;        // MAGI as percent of FPL
  subsidyCutoff: number;     // 400% FPL threshold in cents
}
```

Implement `checkACACliff(input: ACAInput): ACAResult`:
- If age >= 65, return `{ affectsACA: false, ... }` (Medicare eligible)
- Calculate FPL for household: `getFPL(householdSize, state)`
- Calculate cutoff: `getACASubsidyCutoff(householdSize, state)`
- Calculate FPL percent: `(input.magi / fpl) * 100`
- `atSubsidyCliff`: true if magi > cutoff

Implement `calculateACAImpact(baseMAGI: number, conversionAmount: number, householdSize: number, state: string): { crossesCliff: boolean, estimatedLoss: number }`:
- Check if base MAGI is below cliff but base + conversion is above
- `estimatedLoss` is approximate subsidy loss (can use rough estimate of $5,000-$15,000/year for a couple)
- Add comment noting premium calculations are marketplace-specific

Create `lib/calculations/modules/inflation.ts`:
```typescript
/**
 * Adjusts a value for inflation over a number of years
 * @param baseValue - Starting value in cents
 * @param years - Number of years to inflate
 * @param rate - Annual inflation rate as decimal (e.g., 0.025 for 2.5%)
 */
export function adjustForInflation(
  baseValue: number,
  years: number,
  rate: number = 0.025
): number {
  const factor = Math.pow(1 + rate, years);
  return Math.round(baseValue * factor);
}

/**
 * Gets the cumulative inflation factor for a given number of years
 */
export function getInflationFactor(years: number, rate: number = 0.025): number {
  return Math.pow(1 + rate, years);
}

/**
 * Adjusts a value BACKWARD for inflation (present value of future amount)
 */
export function deflateForInflation(
  futureValue: number,
  years: number,
  rate: number = 0.025
): number {
  const factor = Math.pow(1 + rate, years);
  return Math.round(futureValue / factor);
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` - should compile.

Test cases:
1. ACA cliff: Age 60, household 2, CA, MAGI $60,000 - below 400% FPL (~$78,880 for 2)
2. ACA cliff: Age 60, household 2, CA, MAGI $80,000 - above cliff
3. Inflation: $100,000 at 2.5% for 10 years = $128,008
4. Deflation: $128,008 back 10 years at 2.5% = $100,000
  </verify>
  <done>
ACA module detects subsidy cliff for pre-65 clients. Inflation module handles forward and backward adjustments.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` passes
2. All 4 module files exist in lib/calculations/modules/
3. SS taxation handles the "tax torpedo" correctly
4. IRMAA uses cliff-based (not graduated) tier determination
5. ACA only applies to under-65 clients
6. Inflation compounds correctly
</verification>

<success_criteria>
- Social Security taxation returns 0/50/85% taxable based on provisional income
- IRMAA cliff detection is exact (>= threshold triggers tier)
- ACA cliff warning works for pre-Medicare clients
- Inflation adjustment is mathematically correct over 40+ years
- All modules are pure functions with no side effects
</success_criteria>

<output>
After completion, create `.planning/phases/04-calculation-engine-core/04-03-SUMMARY.md`
</output>
