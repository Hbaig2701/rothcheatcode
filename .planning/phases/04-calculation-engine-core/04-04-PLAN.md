---
phase: 04-calculation-engine-core
plan: 04
type: execute
wave: 3
depends_on: [04-02, 04-03]
files_modified:
  - lib/calculations/scenarios/baseline.ts
  - lib/calculations/scenarios/blueprint.ts
  - lib/calculations/engine.ts
  - lib/calculations/index.ts
autonomous: true

must_haves:
  truths:
    - "Baseline scenario projects no-conversion path with RMDs and taxes"
    - "Blueprint scenario projects strategic Roth conversion path"
    - "Simulation engine runs year-by-year for 40+ years in under 2 seconds"
    - "Engine calculates breakeven age where Blueprint surpasses Baseline"
    - "Net worth includes traditional + Roth + taxable balances"
  artifacts:
    - path: "lib/calculations/scenarios/baseline.ts"
      provides: "No-conversion scenario logic"
      exports: ["runBaselineScenario"]
    - path: "lib/calculations/scenarios/blueprint.ts"
      provides: "Strategic conversion scenario logic"
      exports: ["runBlueprintScenario"]
    - path: "lib/calculations/engine.ts"
      provides: "Main simulation orchestration"
      exports: ["runSimulation"]
    - path: "lib/calculations/index.ts"
      provides: "Public API for calculations module"
      exports: ["runSimulation", "SimulationResult", "YearlyResult"]
  key_links:
    - from: "lib/calculations/engine.ts"
      to: "lib/calculations/scenarios/baseline.ts"
      via: "import runBaselineScenario"
      pattern: "import.*runBaselineScenario"
    - from: "lib/calculations/engine.ts"
      to: "lib/calculations/scenarios/blueprint.ts"
      via: "import runBlueprintScenario"
      pattern: "import.*runBlueprintScenario"
    - from: "lib/calculations/scenarios/baseline.ts"
      to: "lib/calculations/modules/*"
      via: "imports all calculation modules"
      pattern: "import.*from.*modules"
---

<objective>
Build the year-by-year simulation engine with Baseline and Blueprint scenarios.

Purpose: This is the core of the application - projecting Roth conversion outcomes over 40+ years.
Output: A simulation engine that takes client data and returns complete year-by-year projections for both scenarios.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-calculation-engine-core/04-RESEARCH.md
@.planning/phases/04-calculation-engine-core/04-01-SUMMARY.md
@.planning/phases/04-calculation-engine-core/04-02-SUMMARY.md
@.planning/phases/04-calculation-engine-core/04-03-SUMMARY.md

@lib/calculations/types.ts
@lib/types/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Baseline (no-conversion) scenario</name>
  <files>
    lib/calculations/scenarios/baseline.ts
  </files>
  <action>
Create `lib/calculations/scenarios/baseline.ts`:

Import all required modules:
```typescript
import { Client } from '@/lib/types/client';
import { YearlyResult } from '../types';
import { calculateAge, getRMDStartAge } from '../utils/age';
import { calculateRMD } from '../modules/rmd';
import { calculateFederalTax, calculateTaxableIncome } from '../modules/federal-tax';
import { calculateStateTax } from '../modules/state-tax';
import { calculateSSTaxableAmount } from '../modules/social-security';
import { calculateNIIT } from '../modules/niit';
import { calculateIRMAA } from '../modules/irmaa';
import { adjustForInflation } from '../modules/inflation';
import { getStandardDeduction } from '@/lib/data/standard-deductions';
```

Implement `runBaselineScenario(client: Client, startYear: number, projectionYears: number): YearlyResult[]`:

Algorithm:
```typescript
export function runBaselineScenario(
  client: Client,
  startYear: number,
  projectionYears: number
): YearlyResult[] {
  const results: YearlyResult[] = [];
  const birthYear = new Date(client.date_of_birth).getFullYear();
  const growthRate = client.growth_rate / 100;  // Convert percentage to decimal
  const inflationRate = client.inflation_rate / 100;

  // Initialize balances from client (all in cents)
  let traditionalBalance = client.traditional_ira;
  let rothBalance = client.roth_ira;
  let taxableBalance = client.taxable_accounts;

  for (let yearOffset = 0; yearOffset < projectionYears; yearOffset++) {
    const year = startYear + yearOffset;
    const age = calculateAge(client.date_of_birth, year);

    // Step 1: Apply growth to all accounts (prior year-end to year-end)
    const traditionalGrowth = Math.round(traditionalBalance * growthRate);
    const rothGrowth = Math.round(rothBalance * growthRate);
    const taxableGrowth = Math.round(taxableBalance * growthRate);

    traditionalBalance += traditionalGrowth;
    rothBalance += rothGrowth;
    taxableBalance += taxableGrowth;

    // Step 2: Calculate RMD (if required)
    const rmdResult = calculateRMD({
      age,
      traditionalBalance,
      birthYear
    });
    const rmdAmount = rmdResult.rmdAmount;

    // Step 3: Take RMD (reduces traditional, adds to taxable income)
    traditionalBalance -= rmdAmount;

    // Step 4: Calculate Social Security income (if started)
    const ssStartAge = client.ss_start_age;
    const ssIncome = age >= ssStartAge
      ? adjustForInflation(client.ss_self + client.ss_spouse, yearOffset, inflationRate)
      : 0;

    // Step 5: Calculate other income (pension, other)
    const pensionIncome = adjustForInflation(client.pension, yearOffset, inflationRate);
    const otherIncome = adjustForInflation(client.other_income, yearOffset, inflationRate);

    // Step 6: Calculate taxable Social Security
    const ssResult = calculateSSTaxableAmount({
      ssBenefits: ssIncome,
      otherIncome: rmdAmount + pensionIncome + otherIncome,
      taxExemptInterest: 0,  // Simplified: assuming no muni bonds
      filingStatus: client.filing_status
    });

    // Step 7: Calculate total gross income
    const grossIncome = rmdAmount + ssResult.taxableAmount + pensionIncome + otherIncome;

    // Step 8: Calculate deductions
    const spouseAge = client.spouse_dob
      ? calculateAge(client.spouse_dob, year)
      : undefined;
    const deductions = getStandardDeduction(client.filing_status, age, spouseAge);

    // Step 9: Calculate taxable income
    const taxableIncome = calculateTaxableIncome(grossIncome, deductions);

    // Step 10: Calculate federal tax
    const federalResult = calculateFederalTax({
      taxableIncome,
      filingStatus: client.filing_status,
      taxYear: year
    });

    // Step 11: Calculate state tax
    const stateResult = calculateStateTax({
      taxableIncome,
      state: client.state,
      filingStatus: client.filing_status
    });

    // Step 12: Calculate NIIT (if enabled)
    const niitResult = client.include_niit
      ? calculateNIIT({
          magi: grossIncome,  // Simplified MAGI
          netInvestmentIncome: taxableGrowth,  // Investment gains
          filingStatus: client.filing_status
        })
      : { applies: false, taxAmount: 0, thresholdExcess: 0 };

    // Step 13: Calculate IRMAA (for age 65+)
    const irmaaResult = age >= 65
      ? calculateIRMAA({
          magi: grossIncome,  // Note: should be 2-year lookback, simplified here
          filingStatus: client.filing_status,
          hasPartD: true  // Assume has Part D
        })
      : { tier: 0, monthlyPartB: 0, monthlyPartD: 0, annualSurcharge: 0 };

    // Step 14: Calculate total taxes
    const totalTax = federalResult.totalTax + stateResult.totalTax +
                     niitResult.taxAmount + irmaaResult.annualSurcharge;

    // Step 15: Pay taxes from taxable account (or reduce it)
    taxableBalance -= totalTax;
    if (taxableBalance < 0) {
      // If taxable account depleted, track negative (would need other funds)
      // In practice, might need to take more from IRA
    }

    // Step 16: Calculate net worth
    const netWorth = traditionalBalance + rothBalance + taxableBalance;

    // Record result
    results.push({
      year,
      age,
      traditionalBalance,
      rothBalance,
      taxableBalance,
      rmdAmount,
      conversionAmount: 0,  // No conversions in baseline
      totalIncome: grossIncome,
      federalTax: federalResult.totalTax,
      stateTax: stateResult.totalTax,
      irmaaSurcharge: irmaaResult.annualSurcharge,
      niitTax: niitResult.taxAmount,
      netWorth
    });
  }

  return results;
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` - should compile.
Verify function signature matches YearlyResult[] return type.
Check all calculation modules are imported and called correctly.
  </verify>
  <done>
Baseline scenario complete. Projects no-conversion path with RMDs, all taxes, and year-over-year balance changes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Blueprint (strategic conversion) scenario</name>
  <files>
    lib/calculations/scenarios/blueprint.ts
  </files>
  <action>
Create `lib/calculations/scenarios/blueprint.ts`:

Similar structure to baseline, but adds Roth conversion logic.

Import same modules plus strategy helper:
```typescript
// ... same imports as baseline
import { checkACACliff } from '../modules/aca';
import { isNearIRMAACliff } from '../modules/irmaa';
```

Define strategy conversion targets:
```typescript
const STRATEGY_TARGETS = {
  conservative: {
    // Fill up to top of 22% bracket
    targetBracket: 22,
    irmaaAvoidance: true
  },
  moderate: {
    // Fill up to top of 24% bracket
    targetBracket: 24,
    irmaaAvoidance: true
  },
  aggressive: {
    // Fill up to top of 32% bracket
    targetBracket: 32,
    irmaaAvoidance: false
  },
  irmaa_safe: {
    // Stay below IRMAA Tier 1 threshold
    targetBracket: 24,
    irmaaAvoidance: true,
    strictIRMAA: true
  }
};
```

Implement `runBlueprintScenario(client: Client, startYear: number, projectionYears: number): YearlyResult[]`:

Key differences from baseline:
1. During conversion window (start_age to end_age), calculate optimal conversion amount
2. Conversion amount = bracket headroom - current taxable income (up to IRA balance)
3. If `tax_payment_source === 'from_ira'`, gross up conversion to cover tax
4. If IRMAA-safe strategy, cap conversion to stay below IRMAA thresholds
5. Move conversion amount from traditional to Roth
6. Pay conversion tax from taxable account or IRA (based on setting)

Conversion calculation logic:
```typescript
function calculateConversionAmount(
  client: Client,
  age: number,
  year: number,
  currentTaxableIncome: number,
  traditionalBalance: number,
  grossIncome: number
): number {
  const strategy = STRATEGY_TARGETS[client.strategy];

  // Check if in conversion window
  if (age < client.start_age || age > client.end_age) {
    return 0;
  }

  // Get target bracket threshold
  const brackets = getFederalBrackets(year, client.filing_status);
  const targetBracket = brackets.find(b => b.rate === strategy.targetBracket);
  if (!targetBracket) return 0;

  // Calculate headroom (how much room before hitting target bracket ceiling)
  const headroom = targetBracket.upper - currentTaxableIncome;
  if (headroom <= 0) return 0;

  // Apply IRMAA constraint if needed
  let maxConversion = headroom;
  if (strategy.irmaaAvoidance || strategy.strictIRMAA) {
    const irmaaHeadroom = calculateIRMAAHeadroom(grossIncome, client.filing_status);
    if (strategy.strictIRMAA) {
      maxConversion = Math.min(maxConversion, irmaaHeadroom);
    }
  }

  // Cap at available traditional balance
  maxConversion = Math.min(maxConversion, traditionalBalance);

  // If paying tax from IRA, need to gross up
  if (client.tax_payment_source === 'from_ira') {
    // Effective rate in target bracket
    const effectiveRate = strategy.targetBracket / 100;
    // Gross-up: amount / (1 - rate) - amount
    // But simpler to just take less since tax comes from same pool
    maxConversion = Math.round(maxConversion * (1 - effectiveRate));
  }

  return Math.max(0, maxConversion);
}
```

The main loop is similar to baseline but:
- Calculates conversion amount after RMD
- Adds conversion to taxable income
- Moves converted amount from traditional to Roth
- Pays conversion tax from appropriate source
  </action>
  <verify>
Run `npx tsc --noEmit` - should compile.
Verify conversion logic respects:
1. Conversion window (start_age to end_age)
2. Strategy target bracket
3. IRMAA avoidance setting
4. Tax payment source setting
  </verify>
  <done>
Blueprint scenario complete. Implements 4 strategies with bracket-filling and IRMAA awareness.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create simulation engine and public API</name>
  <files>
    lib/calculations/engine.ts
    lib/calculations/index.ts
  </files>
  <action>
Create `lib/calculations/engine.ts`:

```typescript
import { Client } from '@/lib/types/client';
import { SimulationInput, SimulationResult, YearlyResult } from './types';
import { runBaselineScenario } from './scenarios/baseline';
import { runBlueprintScenario } from './scenarios/blueprint';

/**
 * Calculate the breakeven age where Blueprint surpasses Baseline
 */
function calculateBreakEvenAge(
  baseline: YearlyResult[],
  blueprint: YearlyResult[]
): number | null {
  for (let i = 0; i < baseline.length; i++) {
    if (blueprint[i].netWorth > baseline[i].netWorth) {
      return blueprint[i].age;
    }
  }
  return null;  // Blueprint never surpasses (rare)
}

/**
 * Calculate total tax savings over projection period
 */
function calculateTaxSavings(
  baseline: YearlyResult[],
  blueprint: YearlyResult[]
): number {
  const baselineTotalTax = baseline.reduce(
    (sum, year) => sum + year.federalTax + year.stateTax + year.niitTax + year.irmaaSurcharge,
    0
  );
  const blueprintTotalTax = blueprint.reduce(
    (sum, year) => sum + year.federalTax + year.stateTax + year.niitTax + year.irmaaSurcharge,
    0
  );
  return baselineTotalTax - blueprintTotalTax;
}

/**
 * Calculate heir benefit (tax savings on inherited IRA)
 * Traditional IRA inheritance is fully taxable at heir's bracket
 * Roth IRA inheritance is tax-free
 */
function calculateHeirBenefit(
  baseline: YearlyResult[],
  blueprint: YearlyResult[],
  heirBracket: string
): number {
  const lastBaseline = baseline[baseline.length - 1];
  const lastBlueprint = blueprint[blueprint.length - 1];

  // Parse heir bracket (e.g., "32" -> 32%)
  const heirRate = parseInt(heirBracket, 10) / 100 || 0.32;

  // Traditional IRA at death will be taxed at heir's rate
  const baselineHeirTax = Math.round(lastBaseline.traditionalBalance * heirRate);
  const blueprintHeirTax = Math.round(lastBlueprint.traditionalBalance * heirRate);

  // Benefit is reduced heir tax + Roth is tax-free
  return baselineHeirTax - blueprintHeirTax;
}

/**
 * Main simulation function
 */
export function runSimulation(input: SimulationInput): SimulationResult {
  const { client, startYear, endYear } = input;
  const projectionYears = endYear - startYear + 1;

  // Run both scenarios
  const baseline = runBaselineScenario(client, startYear, projectionYears);
  const blueprint = runBlueprintScenario(client, startYear, projectionYears);

  // Calculate summary metrics
  const breakEvenAge = calculateBreakEvenAge(baseline, blueprint);
  const totalTaxSavings = calculateTaxSavings(baseline, blueprint);
  const heirBenefit = calculateHeirBenefit(baseline, blueprint, client.heir_bracket);

  return {
    baseline,
    blueprint,
    breakEvenAge,
    totalTaxSavings,
    heirBenefit
  };
}

/**
 * Create simulation input from client data
 */
export function createSimulationInput(client: Client): SimulationInput {
  const birthYear = new Date(client.date_of_birth).getFullYear();
  const currentYear = new Date().getFullYear();
  const currentAge = currentYear - birthYear;

  return {
    client,
    startYear: currentYear,
    endYear: currentYear + client.projection_years
  };
}
```

Create `lib/calculations/index.ts` (public API):

```typescript
// Main simulation API
export { runSimulation, createSimulationInput } from './engine';

// Types
export type {
  SimulationInput,
  SimulationResult,
  YearlyResult,
  FederalTaxResult,
  StateTaxResult,
  RMDResult,
  NIITResult,
  IRMAAResult,
  SSTaxResult
} from './types';

// Utility functions (for potential direct use)
export { calculateAge, getRMDStartAge } from './utils/age';
export { centsToDollars, dollarsToCents, formatCurrency } from './utils/money';

// Individual calculation modules (for testing/debugging)
export { calculateRMD } from './modules/rmd';
export { calculateFederalTax } from './modules/federal-tax';
export { calculateStateTax } from './modules/state-tax';
export { calculateNIIT } from './modules/niit';
export { calculateIRMAA } from './modules/irmaa';
export { calculateSSTaxableAmount } from './modules/social-security';
export { checkACACliff } from './modules/aca';
export { adjustForInflation } from './modules/inflation';
```
  </action>
  <verify>
Run `npx tsc --noEmit` - should compile.
Verify all exports are accessible: `import { runSimulation, YearlyResult } from '@/lib/calculations'`
  </verify>
  <done>
Simulation engine complete. Runs both scenarios, calculates breakeven, tax savings, and heir benefit. Public API exports all needed types and functions.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` passes
2. All 4 files exist: baseline.ts, blueprint.ts, engine.ts, index.ts
3. Engine accepts Client and returns SimulationResult
4. Breakeven age calculated correctly
5. Both scenarios produce correct number of yearly results
6. Performance: Simulation should complete in < 2 seconds for 40 years
</verification>

<success_criteria>
- Baseline scenario projects no-conversion path correctly
- Blueprint scenario implements all 4 strategies (conservative, moderate, aggressive, irmaa_safe)
- Tax payment source option works (from_ira vs from_taxable)
- Breakeven age is calculated when Blueprint surpasses Baseline
- Heir benefit calculation uses configured heir bracket
- Public API exports cleanly from lib/calculations/index.ts
- Simulation completes in < 2 seconds for 40-year projection
</success_criteria>

<output>
After completion, create `.planning/phases/04-calculation-engine-core/04-04-SUMMARY.md`
</output>
