---
phase: 01-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/actions/auth.ts
  - app/(auth)/auth/callback/route.ts
  - app/(auth)/auth/confirm/route.ts
autonomous: true

must_haves:
  truths:
    - "Server actions exist for login, signup, logout, OAuth, and magic link"
    - "OAuth callback exchanges code for session and redirects"
    - "Email confirmation verifies token and establishes session"
  artifacts:
    - path: "lib/actions/auth.ts"
      provides: "Auth server actions"
      exports: ["login", "signup", "logout", "signInWithGoogle", "signInWithMagicLink"]
    - path: "app/(auth)/auth/callback/route.ts"
      provides: "OAuth/magic link callback handler"
      exports: ["GET"]
    - path: "app/(auth)/auth/confirm/route.ts"
      provides: "Email confirmation handler"
      exports: ["GET"]
  key_links:
    - from: "lib/actions/auth.ts"
      to: "lib/supabase/server.ts"
      via: "createClient import"
      pattern: "import.*createClient.*from.*supabase/server"
    - from: "app/(auth)/auth/callback/route.ts"
      to: "lib/supabase/server.ts"
      via: "createClient import"
      pattern: "import.*createClient.*from.*supabase/server"
---

<objective>
Create the auth foundation: Server Actions for all auth operations and route handlers for OAuth/email callbacks.

Purpose: Provides the backend auth logic that login/signup pages will consume. Must exist before UI can function.
Output: Working server actions and callback routes ready for UI integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/01-authentication/01-RESEARCH.md

Existing infrastructure:
- lib/supabase/server.ts - Server client (createClient is async, returns Supabase client)
- lib/supabase/client.ts - Browser client
- lib/supabase/middleware.ts - Session refresh
- middleware.ts - Root middleware calling updateSession
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth server actions</name>
  <files>lib/actions/auth.ts</files>
  <action>
Create lib/actions/auth.ts with 'use server' directive containing these functions:

1. `login(formData: FormData)` - Email/password login
   - Call `supabase.auth.signInWithPassword({ email, password })`
   - On error, return `{ error: error.message }`
   - On success, call `revalidatePath('/', 'layout')` then `redirect('/dashboard')`

2. `signup(formData: FormData)` - Email/password signup
   - Call `supabase.auth.signUp({ email, password, options: { emailRedirectTo } })`
   - emailRedirectTo: `${process.env.NEXT_PUBLIC_SITE_URL}/auth/callback`
   - On error, return `{ error: error.message }`
   - On success, redirect to `/login?message=Check your email to confirm your account`

3. `signInWithGoogle()` - Google OAuth
   - Call `supabase.auth.signInWithOAuth({ provider: 'google', options: { redirectTo } })`
   - redirectTo: `${process.env.NEXT_PUBLIC_SITE_URL}/auth/callback`
   - On error, return `{ error: error.message }`
   - On success, redirect to `data.url`

4. `signInWithMagicLink(formData: FormData)` - Magic link auth
   - Call `supabase.auth.signInWithOtp({ email, options: { emailRedirectTo } })`
   - emailRedirectTo: `${process.env.NEXT_PUBLIC_SITE_URL}/auth/callback`
   - On error, return `{ error: error.message }`
   - On success, return `{ success: 'Check your email for the magic link' }`

5. `logout()` - Sign out
   - Call `supabase.auth.signOut()`
   - Call `revalidatePath('/', 'layout')`
   - Redirect to `/login`

IMPORTANT: Use `await createClient()` (it's async). Import from '@/lib/supabase/server'.
Import redirect from 'next/navigation', revalidatePath from 'next/cache'.
  </action>
  <verify>
File exists with correct exports:
```bash
grep -E "^export async function (login|signup|logout|signInWithGoogle|signInWithMagicLink)" lib/actions/auth.ts
```
Should show all 5 function exports.
  </verify>
  <done>All 5 auth server actions exported and using correct Supabase client methods</done>
</task>

<task type="auto">
  <name>Task 2: Create OAuth/magic link callback route</name>
  <files>app/(auth)/auth/callback/route.ts</files>
  <action>
Create app/(auth)/auth/callback/route.ts (create directories as needed).

This route handles the redirect from OAuth providers and magic links:

```typescript
import { NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'

export async function GET(request: Request) {
  const { searchParams, origin } = new URL(request.url)
  const code = searchParams.get('code')
  const next = searchParams.get('next') ?? '/dashboard'

  if (code) {
    const supabase = await createClient()
    const { error } = await supabase.auth.exchangeCodeForSession(code)

    if (!error) {
      return NextResponse.redirect(`${origin}${next}`)
    }
  }

  // Return to login with error
  return NextResponse.redirect(`${origin}/login?error=Could not authenticate`)
}
```

Key points:
- Extracts `code` from URL params (provided by Supabase/OAuth)
- Exchanges code for session using Supabase
- Redirects to dashboard on success, login with error message on failure
  </action>
  <verify>
```bash
test -f app/\(auth\)/auth/callback/route.ts && grep "exchangeCodeForSession" app/\(auth\)/auth/callback/route.ts
```
  </verify>
  <done>Callback route exists and exchanges auth code for session</done>
</task>

<task type="auto">
  <name>Task 3: Create email confirmation route</name>
  <files>app/(auth)/auth/confirm/route.ts</files>
  <action>
Create app/(auth)/auth/confirm/route.ts for email confirmation links.

This handles the token_hash flow (more reliable than code exchange for email links):

```typescript
import { type EmailOtpType } from '@supabase/supabase-js'
import { NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'

export async function GET(request: Request) {
  const { searchParams, origin } = new URL(request.url)
  const token_hash = searchParams.get('token_hash')
  const type = searchParams.get('type') as EmailOtpType | null
  const next = searchParams.get('next') ?? '/dashboard'

  if (token_hash && type) {
    const supabase = await createClient()
    const { error } = await supabase.auth.verifyOtp({
      type,
      token_hash,
    })

    if (!error) {
      return NextResponse.redirect(`${origin}${next}`)
    }
  }

  return NextResponse.redirect(`${origin}/login?error=Could not verify email`)
}
```

Key points:
- Uses verifyOtp with token_hash (works across browsers/devices)
- Type is EmailOtpType (signup, recovery, email_change, etc.)
- Redirects to dashboard on success
  </action>
  <verify>
```bash
test -f app/\(auth\)/auth/confirm/route.ts && grep "verifyOtp" app/\(auth\)/auth/confirm/route.ts
```
  </verify>
  <done>Email confirmation route exists and verifies OTP token</done>
</task>

</tasks>

<verification>
All files created:
```bash
ls -la lib/actions/auth.ts app/\(auth\)/auth/callback/route.ts app/\(auth\)/auth/confirm/route.ts
```

TypeScript compiles:
```bash
npx tsc --noEmit lib/actions/auth.ts 2>&1 | head -20
```

(Note: Full type checking may show unrelated errors from other files; focus on auth.ts)
</verification>

<success_criteria>
- lib/actions/auth.ts exports login, signup, logout, signInWithGoogle, signInWithMagicLink
- app/(auth)/auth/callback/route.ts handles OAuth code exchange
- app/(auth)/auth/confirm/route.ts handles email verification
- All files use async createClient from lib/supabase/server
</success_criteria>

<output>
After completion, create `.planning/phases/01-authentication/01-01-SUMMARY.md`
</output>
