---
phase: 02
plan: 02
wave: 2
title: API Routes - Client CRUD Endpoints
depends_on: ["02-01"]
files_modified:
  - app/api/clients/route.ts
  - app/api/clients/[id]/route.ts
autonomous: true
estimated_tasks: 2

must_haves:
  truths:
    - "GET /api/clients returns list of clients for authenticated user"
    - "POST /api/clients creates a new client with validation"
    - "GET /api/clients/[id] returns a single client"
    - "PUT /api/clients/[id] updates a client with validation"
    - "DELETE /api/clients/[id] removes a client"
    - "All endpoints return 401 for unauthenticated requests"
    - "Invalid data returns 400 with validation errors"
  artifacts:
    - path: "app/api/clients/route.ts"
      provides: "GET (list) and POST (create) endpoints"
      exports: ["GET", "POST"]
    - path: "app/api/clients/[id]/route.ts"
      provides: "GET (detail), PUT (update), DELETE endpoints"
      exports: ["GET", "PUT", "DELETE"]
  key_links:
    - from: "app/api/clients/route.ts"
      to: "lib/supabase/server.ts"
      via: "createClient()"
      pattern: "createClient"
    - from: "app/api/clients/route.ts"
      to: "lib/validations/client.ts"
      via: "Zod schema validation"
      pattern: "clientCreateSchema"
---

# API Routes - Client CRUD Endpoints

## Objective
Create Next.js API route handlers for all client CRUD operations with proper authentication (using getUser()), Zod validation, and error handling.

## Tasks

<task id="1">
<title>Create collection routes: GET /api/clients and POST /api/clients</title>
<action>
Create `app/api/clients/route.ts`:

```typescript
import { createClient } from "@/lib/supabase/server";
import { NextRequest, NextResponse } from "next/server";
import { clientCreateSchema } from "@/lib/validations/client";

// GET /api/clients - List all clients for the authenticated user
export async function GET(request: NextRequest) {
  const supabase = await createClient();

  // CRITICAL: Use getUser() NOT getSession() for secure server-side auth
  const { data: { user }, error: authError } = await supabase.auth.getUser();

  if (authError || !user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  // RLS automatically filters to user's clients via user_id policy
  const { data, error } = await supabase
    .from("clients")
    .select("*")
    .order("created_at", { ascending: false });

  if (error) {
    console.error("Error fetching clients:", error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }

  return NextResponse.json(data);
}

// POST /api/clients - Create a new client
export async function POST(request: NextRequest) {
  const supabase = await createClient();

  const { data: { user }, error: authError } = await supabase.auth.getUser();
  if (authError || !user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  let body;
  try {
    body = await request.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON body" }, { status: 400 });
  }

  // Validate request body with Zod
  const parsed = clientCreateSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json(
      { error: "Validation failed", details: parsed.error.flatten() },
      { status: 400 }
    );
  }

  // Insert client with user_id from authenticated user
  const { data, error } = await supabase
    .from("clients")
    .insert({ ...parsed.data, user_id: user.id })
    .select()
    .single();

  if (error) {
    console.error("Error creating client:", error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }

  return NextResponse.json(data, { status: 201 });
}
```

**CRITICAL PATTERNS:**
- Use `supabase.auth.getUser()` not `getSession()` - this validates the JWT server-side
- RLS on the clients table handles authorization (user can only see their own clients)
- Always validate with Zod before inserting
- Return 401 for auth errors, 400 for validation errors, 500 for database errors
</action>
<verify>
1. Run `npx tsc --noEmit` - no type errors
2. Start dev server: `npm run dev`
3. Test unauthorized access:
   ```bash
   curl -s http://localhost:3000/api/clients | grep -q "Unauthorized" && echo "PASS: Unauthorized returns 401"
   ```
</verify>
</task>

<task id="2" depends_on="1">
<title>Create item routes: GET, PUT, DELETE /api/clients/[id]</title>
<action>
Create `app/api/clients/[id]/route.ts`:

```typescript
import { createClient } from "@/lib/supabase/server";
import { NextRequest, NextResponse } from "next/server";
import { clientUpdateSchema } from "@/lib/validations/client";

type RouteContext = { params: Promise<{ id: string }> };

// GET /api/clients/[id] - Get a single client
export async function GET(request: NextRequest, context: RouteContext) {
  const { id } = await context.params;
  const supabase = await createClient();

  const { data: { user }, error: authError } = await supabase.auth.getUser();
  if (authError || !user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { data, error } = await supabase
    .from("clients")
    .select("*")
    .eq("id", id)
    .single();

  if (error) {
    // PGRST116 = "The result contains 0 rows" (not found or RLS blocked)
    if (error.code === "PGRST116") {
      return NextResponse.json({ error: "Client not found" }, { status: 404 });
    }
    console.error("Error fetching client:", error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }

  return NextResponse.json(data);
}

// PUT /api/clients/[id] - Update a client
export async function PUT(request: NextRequest, context: RouteContext) {
  const { id } = await context.params;
  const supabase = await createClient();

  const { data: { user }, error: authError } = await supabase.auth.getUser();
  if (authError || !user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  let body;
  try {
    body = await request.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON body" }, { status: 400 });
  }

  // Validate with partial schema (all fields optional for updates)
  const parsed = clientUpdateSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json(
      { error: "Validation failed", details: parsed.error.flatten() },
      { status: 400 }
    );
  }

  // Update client and set updated_at timestamp
  const { data, error } = await supabase
    .from("clients")
    .update({ ...parsed.data, updated_at: new Date().toISOString() })
    .eq("id", id)
    .select()
    .single();

  if (error) {
    if (error.code === "PGRST116") {
      return NextResponse.json({ error: "Client not found" }, { status: 404 });
    }
    console.error("Error updating client:", error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }

  return NextResponse.json(data);
}

// DELETE /api/clients/[id] - Delete a client
export async function DELETE(request: NextRequest, context: RouteContext) {
  const { id } = await context.params;
  const supabase = await createClient();

  const { data: { user }, error: authError } = await supabase.auth.getUser();
  if (authError || !user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { error } = await supabase
    .from("clients")
    .delete()
    .eq("id", id);

  if (error) {
    console.error("Error deleting client:", error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }

  // Return 204 No Content on successful deletion
  return new NextResponse(null, { status: 204 });
}
```

**IMPORTANT NOTES:**
- Next.js 15+ requires `params` to be awaited: `const { id } = await context.params`
- `PGRST116` error code means no rows returned (either not found OR blocked by RLS)
- RLS ensures users can only access their own clients - no additional checks needed
- DELETE returns 204 with no body on success
</action>
<verify>
1. Run `npx tsc --noEmit` - no type errors
2. Verify files exist:
   ```bash
   ls app/api/clients/route.ts app/api/clients/\[id\]/route.ts
   ```
3. Test unauthorized access to detail route:
   ```bash
   curl -s http://localhost:3000/api/clients/test-id | grep -q "Unauthorized" && echo "PASS: Detail route returns 401"
   ```
</verify>
</task>

## Verification

After completing all tasks:

1. **Type checking passes:**
   ```bash
   npx tsc --noEmit
   ```

2. **Routes exist:**
   ```bash
   ls -la app/api/clients/route.ts app/api/clients/\[id\]/route.ts
   ```

3. **401 on unauthenticated requests:**
   ```bash
   curl -s -w "%{http_code}" http://localhost:3000/api/clients -o /dev/null
   # Should output: 401
   ```

4. **Endpoints are reachable (even if returning 401):**
   - GET http://localhost:3000/api/clients -> 401
   - POST http://localhost:3000/api/clients -> 401
   - GET http://localhost:3000/api/clients/some-id -> 401
   - PUT http://localhost:3000/api/clients/some-id -> 401
   - DELETE http://localhost:3000/api/clients/some-id -> 401

## Rollback

If this plan fails:
1. Remove API routes: `rm -rf app/api/clients`
2. Previous plan's work remains intact
