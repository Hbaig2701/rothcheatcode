---
phase: 06-multi-strategy-comparison
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/calculations/types.ts
  - lib/calculations/strategy-definitions.ts
  - lib/calculations/multi-strategy.ts
  - lib/calculations/index.ts
autonomous: true

must_haves:
  truths:
    - "Multi-strategy simulation runs all 4 strategies in a single call"
    - "Best strategy is determined by highest ending net worth with tie-breakers"
    - "Comparison metrics extracted for each strategy (wealth, tax savings, IRMAA, breakeven)"
    - "Strategy definitions are centralized and reusable"
  artifacts:
    - path: "lib/calculations/types.ts"
      provides: "StrategyType, StrategyComparisonMetrics, MultiStrategyResult types"
      contains: "MultiStrategyResult"
    - path: "lib/calculations/strategy-definitions.ts"
      provides: "Centralized strategy configuration"
      exports: ["STRATEGY_DEFINITIONS", "STRATEGIES", "StrategyDefinition"]
    - path: "lib/calculations/multi-strategy.ts"
      provides: "Multi-strategy simulation wrapper"
      exports: ["runMultiStrategySimulation"]
  key_links:
    - from: "lib/calculations/multi-strategy.ts"
      to: "lib/calculations/engine.ts"
      via: "import runSimulation"
      pattern: "import.*runSimulation.*from.*engine"
    - from: "lib/calculations/multi-strategy.ts"
      to: "lib/calculations/strategy-definitions.ts"
      via: "import STRATEGIES"
      pattern: "import.*STRATEGIES"
    - from: "lib/calculations/index.ts"
      to: "lib/calculations/multi-strategy.ts"
      via: "export runMultiStrategySimulation"
      pattern: "export.*runMultiStrategySimulation"
---

<objective>
Create the multi-strategy calculation wrapper and supporting types.

Purpose: Enable running all 4 Roth conversion strategies simultaneously to power the comparison table. This wrapper calls the existing simulation engine 4 times with different strategy configurations and determines the "best" strategy.
Output: `runMultiStrategySimulation()` function returning all 4 strategy results with comparison metrics and best strategy indicator.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-multi-strategy-comparison/06-RESEARCH.md

@lib/calculations/types.ts
@lib/calculations/engine.ts
@lib/calculations/index.ts
@lib/types/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add multi-strategy types to calculations</name>
  <files>lib/calculations/types.ts</files>
  <action>
Update `lib/calculations/types.ts` to add these types at the end of the file (after existing types):

```typescript
// =============================================================================
// Multi-Strategy Comparison Types (Phase 06)
// =============================================================================

/**
 * The 4 supported Roth conversion strategies
 */
export type StrategyType = 'conservative' | 'moderate' | 'aggressive' | 'irmaa_safe';

/**
 * Comparison metrics for a single strategy
 * All currency values in cents
 */
export interface StrategyComparisonMetrics {
  endingWealth: number;        // Final year net worth (cents)
  taxSavings: number;          // Lifetime tax savings vs baseline (cents)
  breakEvenAge: number | null; // Age when Blueprint surpasses Baseline
  totalIRMAA: number;          // Total IRMAA surcharges paid (cents)
  heirBenefit: number;         // Tax benefit to heirs (cents)
  totalConversions: number;    // Sum of all conversions (cents)
}

/**
 * Result of running all 4 strategies
 */
export interface MultiStrategyResult {
  strategies: Record<StrategyType, SimulationResult>;
  bestStrategy: StrategyType;
  comparisonMetrics: Record<StrategyType, StrategyComparisonMetrics>;
}
```

Key implementation notes:
- StrategyType matches the existing `client.strategy` values from client.ts
- All currency values in cents (consistent with project convention from STATE.md)
- MultiStrategyResult contains the full SimulationResult per strategy (for detail views) plus extracted comparison metrics
  </action>
  <verify>
Run `npx tsc --noEmit` - should compile.
Verify types exist: `grep "MultiStrategyResult" lib/calculations/types.ts`
  </verify>
  <done>
Multi-strategy types added. StrategyType, StrategyComparisonMetrics, and MultiStrategyResult are defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create strategy definitions constant</name>
  <files>lib/calculations/strategy-definitions.ts</files>
  <action>
Create `lib/calculations/strategy-definitions.ts`:

```typescript
import { StrategyType } from './types';

/**
 * Configuration for a Roth conversion strategy
 */
export interface StrategyDefinition {
  name: string;              // Display name
  description: string;       // Brief explanation
  targetBracket: number;     // Fill up to this federal tax bracket %
  irmaaAvoidance: boolean;   // Try to stay below IRMAA thresholds
  strictIRMAA: boolean;      // Hard cap at IRMAA threshold
  riskLevel: 'low' | 'medium' | 'high';
}

/**
 * Centralized strategy configurations
 * Used by:
 * - Blueprint scenario to determine conversion amounts
 * - Comparison table to display strategy names/descriptions
 * - Best strategy determination for tie-breaking by risk
 */
export const STRATEGY_DEFINITIONS: Record<StrategyType, StrategyDefinition> = {
  conservative: {
    name: 'Conservative',
    description: 'Stay within current tax bracket',
    targetBracket: 22,
    irmaaAvoidance: true,
    strictIRMAA: false,
    riskLevel: 'low'
  },
  moderate: {
    name: 'Moderate',
    description: 'Fill up to next bracket',
    targetBracket: 24,
    irmaaAvoidance: true,
    strictIRMAA: false,
    riskLevel: 'medium'
  },
  aggressive: {
    name: 'Aggressive',
    description: 'Fill up to 32% bracket',
    targetBracket: 32,
    irmaaAvoidance: false,
    strictIRMAA: false,
    riskLevel: 'high'
  },
  irmaa_safe: {
    name: 'IRMAA-Safe',
    description: 'Stay below Medicare surcharges',
    targetBracket: 24,
    irmaaAvoidance: true,
    strictIRMAA: true,
    riskLevel: 'low'
  }
};

/**
 * Ordered list of strategies for iteration
 * Order: by display position in comparison table
 */
export const STRATEGIES: StrategyType[] = [
  'conservative',
  'moderate',
  'aggressive',
  'irmaa_safe'
];

/**
 * Priority order for tie-breaking (lower index = preferred)
 * Used when two strategies have identical ending wealth
 */
export const STRATEGY_PRIORITY: StrategyType[] = [
  'irmaa_safe',     // Lowest risk, preferred on tie
  'conservative',   // Low risk
  'moderate',       // Medium risk
  'aggressive'      // Highest risk, least preferred on tie
];
```

Key implementation notes:
- Strategy definitions match Phase 04 blueprint.ts STRATEGY_TARGETS (from 04-04-PLAN.md)
- STRATEGIES array for iteration in display order
- STRATEGY_PRIORITY for tie-breaking (lower IRMAA and lower risk preferred)
  </action>
  <verify>
Run `npx tsc --noEmit` - should compile.
Check file exists: `ls lib/calculations/strategy-definitions.ts`
Verify exports: `grep "export const STRATEGY_DEFINITIONS" lib/calculations/strategy-definitions.ts`
  </verify>
  <done>
Strategy definitions created. STRATEGY_DEFINITIONS, STRATEGIES, and STRATEGY_PRIORITY constants are exported.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create multi-strategy simulation wrapper</name>
  <files>
    lib/calculations/multi-strategy.ts
    lib/calculations/index.ts
  </files>
  <action>
Create `lib/calculations/multi-strategy.ts`:

```typescript
import { Client } from '@/lib/types/client';
import {
  SimulationResult,
  MultiStrategyResult,
  StrategyType,
  StrategyComparisonMetrics
} from './types';
import { runSimulation } from './engine';
import { STRATEGIES, STRATEGY_PRIORITY } from './strategy-definitions';

/**
 * Extract comparison metrics from a simulation result
 */
function extractComparisonMetrics(result: SimulationResult): StrategyComparisonMetrics {
  const lastYear = result.blueprint[result.blueprint.length - 1];

  return {
    endingWealth: lastYear.netWorth,
    taxSavings: result.totalTaxSavings,
    breakEvenAge: result.breakEvenAge,
    totalIRMAA: result.blueprint.reduce(
      (sum, year) => sum + year.irmaaSurcharge,
      0
    ),
    heirBenefit: result.heirBenefit,
    totalConversions: result.blueprint.reduce(
      (sum, year) => sum + year.conversionAmount,
      0
    )
  };
}

/**
 * Determine the best strategy based on ending wealth with tie-breakers
 *
 * Primary: Highest ending net worth
 * Tie-breaker 1: Lowest IRMAA surcharges
 * Tie-breaker 2: Lowest risk (STRATEGY_PRIORITY order)
 */
function determineBestStrategy(
  results: Record<StrategyType, SimulationResult>
): StrategyType {
  // Build ranked list
  const ranked = Object.entries(results)
    .map(([strategy, result]) => {
      const lastYear = result.blueprint[result.blueprint.length - 1];
      return {
        strategy: strategy as StrategyType,
        wealth: lastYear.netWorth,
        irmaa: result.blueprint.reduce((s, y) => s + y.irmaaSurcharge, 0)
      };
    })
    .sort((a, b) => {
      // Primary: highest wealth (descending)
      if (b.wealth !== a.wealth) return b.wealth - a.wealth;

      // Tie-breaker 1: lowest IRMAA (ascending)
      if (a.irmaa !== b.irmaa) return a.irmaa - b.irmaa;

      // Tie-breaker 2: lowest risk (based on STRATEGY_PRIORITY index)
      return (
        STRATEGY_PRIORITY.indexOf(a.strategy) -
        STRATEGY_PRIORITY.indexOf(b.strategy)
      );
    });

  return ranked[0].strategy;
}

/**
 * Run simulation for all 4 strategies and compare results
 *
 * @param client - Client data (strategy field will be overridden for each run)
 * @param startYear - First year of projection
 * @param endYear - Last year of projection
 * @returns MultiStrategyResult with all 4 outcomes, best strategy, and comparison metrics
 */
export function runMultiStrategySimulation(
  client: Client,
  startYear: number,
  endYear: number
): MultiStrategyResult {
  const results: Record<StrategyType, SimulationResult> = {} as Record<StrategyType, SimulationResult>;

  // Run simulation for each strategy
  for (const strategy of STRATEGIES) {
    // Create client variant with this strategy
    // IMPORTANT: Use spread to avoid mutating original client
    const clientWithStrategy: Client = {
      ...client,
      strategy
    };

    results[strategy] = runSimulation({
      client: clientWithStrategy,
      startYear,
      endYear
    });
  }

  // Determine best strategy
  const bestStrategy = determineBestStrategy(results);

  // Extract comparison metrics for each strategy
  const comparisonMetrics: Record<StrategyType, StrategyComparisonMetrics> = {} as Record<StrategyType, StrategyComparisonMetrics>;
  for (const strategy of STRATEGIES) {
    comparisonMetrics[strategy] = extractComparisonMetrics(results[strategy]);
  }

  return {
    strategies: results,
    bestStrategy,
    comparisonMetrics
  };
}
```

Update `lib/calculations/index.ts` to export multi-strategy functions and types. Add these exports:

```typescript
// Multi-Strategy Comparison (Phase 06)
export { runMultiStrategySimulation } from './multi-strategy';
export { STRATEGY_DEFINITIONS, STRATEGIES, STRATEGY_PRIORITY } from './strategy-definitions';
export type { StrategyDefinition } from './strategy-definitions';
export type {
  StrategyType,
  StrategyComparisonMetrics,
  MultiStrategyResult
} from './types';
```

Key implementation notes:
- Spreads client to avoid mutation (anti-pattern from research)
- Loops through STRATEGIES array for consistent order
- determineBestStrategy has 3-level tie-breaking
- extractComparisonMetrics pulls key values from SimulationResult
- All exports added to public API via index.ts
  </action>
  <verify>
Run `npx tsc --noEmit` - should compile.
Check multi-strategy file exists: `ls lib/calculations/multi-strategy.ts`
Check exports in index: `grep "runMultiStrategySimulation" lib/calculations/index.ts`
  </verify>
  <done>
Multi-strategy simulation wrapper complete. runMultiStrategySimulation() runs all 4 strategies, determines best, and extracts comparison metrics.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` passes with no errors
2. Types file contains StrategyType, StrategyComparisonMetrics, MultiStrategyResult
3. Strategy definitions file exports STRATEGY_DEFINITIONS, STRATEGIES, STRATEGY_PRIORITY
4. Multi-strategy file exports runMultiStrategySimulation
5. All exports accessible from lib/calculations/index.ts
</verification>

<success_criteria>
- StrategyType matches client.strategy values (conservative, moderate, aggressive, irmaa_safe)
- STRATEGY_DEFINITIONS has all 4 strategies with name, description, targetBracket, riskLevel
- runMultiStrategySimulation accepts client + year range, returns MultiStrategyResult
- determineBestStrategy implements 3-level tie-breaking (wealth > IRMAA > risk)
- extractComparisonMetrics extracts 6 metrics per strategy
- Client object is not mutated during multi-strategy run
</success_criteria>

<output>
After completion, create `.planning/phases/06-multi-strategy-comparison/06-01-SUMMARY.md`
</output>
