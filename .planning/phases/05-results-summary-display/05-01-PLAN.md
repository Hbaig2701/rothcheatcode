---
phase: 05-results-summary-display
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - lib/calculations/transforms.ts
  - lib/hooks/use-projection.ts
autonomous: true

must_haves:
  truths:
    - "recharts, react-is, and react-countup are installed"
    - "Transform functions convert SimulationResult to chart-ready format"
    - "useProjection hook fetches projection data with TanStack Query"
  artifacts:
    - path: "lib/calculations/transforms.ts"
      provides: "Data transformation utilities for chart and summary display"
      exports: ["transformToChartData", "extractSummaryMetrics", "ChartDataPoint", "SummaryMetrics"]
    - path: "lib/hooks/use-projection.ts"
      provides: "TanStack Query hook for projection API"
      exports: ["useProjection", "useRecalculateProjection"]
  key_links:
    - from: "lib/calculations/transforms.ts"
      to: "lib/types/projection.ts"
      via: "import Projection type"
      pattern: "import.*Projection.*from"
    - from: "lib/hooks/use-projection.ts"
      to: "/api/clients/[id]/projections"
      via: "fetch call to API"
      pattern: "fetch.*projections"
---

<objective>
Install visualization libraries and create data transformation utilities for results display.

Purpose: Establishes the foundation for displaying projection results by installing required libraries and creating the data transformation layer that converts API responses into chart-ready formats.
Output: Installed dependencies (recharts, react-countup), transform utilities, and TanStack Query hook for projections API.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-results-summary-display/05-RESEARCH.md

@lib/types/projection.ts
@lib/hooks/use-clients.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install visualization libraries</name>
  <files>package.json</files>
  <action>
Install the required libraries for charts and animations:

```bash
npm install recharts react-is react-countup
```

This installs:
- `recharts` (^3.6.0) - LINE charts with ResponsiveContainer
- `react-is` - Peer dependency required by Recharts v3
- `react-countup` (^6.5.x) - Animated number counting for stat cards

Verify package.json includes all three dependencies after install.
  </action>
  <verify>
Run `npm ls recharts react-is react-countup` - all three should be listed.
Run `npm run build` - should pass without errors.
  </verify>
  <done>
All three libraries installed and listed in package.json dependencies.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create data transformation utilities</name>
  <files>lib/calculations/transforms.ts</files>
  <action>
Create `lib/calculations/transforms.ts` with functions to convert projection data into chart-ready formats.

```typescript
import { Projection } from '@/lib/types/projection';

/**
 * Data point for wealth chart
 */
export interface ChartDataPoint {
  age: number;
  year: number;
  baseline: number;   // Net worth in cents
  blueprint: number;  // Net worth in cents
}

/**
 * Summary metrics for stat cards
 */
export interface SummaryMetrics {
  baselineEndWealth: number;    // Final year netWorth, cents
  blueprintEndWealth: number;   // Final year netWorth, cents
  difference: number;           // blueprint - baseline, cents
  totalTaxSavings: number;      // From projection, cents
  breakEvenAge: number | null;  // Age where blueprint exceeds baseline
  heirBenefit: number;          // Benefit to heirs, cents
}

/**
 * Transform projection data into chart-ready format
 * Extracts age, year, and net worth from both scenarios
 */
export function transformToChartData(projection: Projection): ChartDataPoint[] {
  // baseline_years and blueprint_years are arrays from the JSONB columns
  const baselineYears = projection.baseline_years;
  const blueprintYears = projection.blueprint_years;

  return baselineYears.map((baseYear, index) => ({
    age: baseYear.age,
    year: baseYear.year,
    baseline: baseYear.netWorth,
    blueprint: blueprintYears[index]?.netWorth ?? 0,
  }));
}

/**
 * Extract summary metrics from projection for stat cards
 * Uses pre-calculated final values from database for efficiency
 */
export function extractSummaryMetrics(projection: Projection): SummaryMetrics {
  return {
    baselineEndWealth: projection.baseline_final_net_worth,
    blueprintEndWealth: projection.blueprint_final_net_worth,
    difference: projection.blueprint_final_net_worth - projection.baseline_final_net_worth,
    totalTaxSavings: projection.total_tax_savings,
    breakEvenAge: projection.break_even_age,
    heirBenefit: projection.heir_benefit,
  };
}

/**
 * Format cents as currency string for display
 * Uses Intl.NumberFormat for proper locale handling
 */
export function formatCurrency(cents: number): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  }).format(cents / 100);
}

/**
 * Format cents for Y-axis labels (abbreviated)
 * Converts to K (thousands) or M (millions) for readability
 */
export function formatAxisValue(cents: number): string {
  const dollars = cents / 100;
  if (Math.abs(dollars) >= 1_000_000) {
    return `$${(dollars / 1_000_000).toFixed(1)}M`;
  }
  if (Math.abs(dollars) >= 1_000) {
    return `$${(dollars / 1_000).toFixed(0)}K`;
  }
  return `$${dollars.toFixed(0)}`;
}
```

Key implementation notes:
- All monetary values in cents (consistent with database and Phase 04)
- `transformToChartData` maps over baseline array, pairs with blueprint by index
- `extractSummaryMetrics` uses pre-calculated DB columns (faster than recalculating)
- `formatCurrency` for full display, `formatAxisValue` for chart axis
  </action>
  <verify>
Run `npx tsc --noEmit` - should compile without errors.
Check file exists: `ls lib/calculations/transforms.ts`
Check exports: `grep -E "export (function|interface)" lib/calculations/transforms.ts` shows all exports.
  </verify>
  <done>
Transform utilities created with ChartDataPoint, SummaryMetrics types and transform/format functions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create useProjection TanStack Query hook</name>
  <files>lib/hooks/use-projection.ts</files>
  <action>
Create `lib/hooks/use-projection.ts` following the existing pattern from `use-clients.ts`.

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { Projection, ProjectionResponse } from '@/lib/types/projection';

/**
 * Query key factory for projections
 * Following established pattern from use-clients.ts
 */
export const projectionKeys = {
  all: ['projections'] as const,
  client: (clientId: string) => [...projectionKeys.all, clientId] as const,
};

/**
 * Fetch projection for a client (uses cached if data unchanged)
 */
async function fetchProjection(clientId: string): Promise<ProjectionResponse> {
  const response = await fetch(`/api/clients/${clientId}/projections`);

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error || 'Failed to fetch projection');
  }

  return response.json();
}

/**
 * Force recalculate projection (ignores cache)
 */
async function recalculateProjection(clientId: string): Promise<ProjectionResponse> {
  const response = await fetch(`/api/clients/${clientId}/projections`, {
    method: 'POST',
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error || 'Failed to recalculate projection');
  }

  return response.json();
}

/**
 * Hook to fetch projection for a client
 * Returns cached projection if client data unchanged, otherwise runs new simulation
 *
 * @param clientId - UUID of the client
 * @param options - Additional query options (enabled, etc.)
 */
export function useProjection(
  clientId: string,
  options?: { enabled?: boolean }
) {
  return useQuery({
    queryKey: projectionKeys.client(clientId),
    queryFn: () => fetchProjection(clientId),
    enabled: options?.enabled ?? true,
    staleTime: 5 * 60 * 1000, // 5 minutes - projection data is computed, changes rarely
  });
}

/**
 * Hook to force recalculate a projection
 * Use when user explicitly wants fresh calculation (e.g., after editing client)
 */
export function useRecalculateProjection() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: recalculateProjection,
    onSuccess: (data, clientId) => {
      // Update the cache with new projection
      queryClient.setQueryData(projectionKeys.client(clientId), data);
    },
  });
}
```

Key implementation notes:
- Query key factory follows `use-clients.ts` pattern for cache management
- `useProjection` is the primary hook - GET returns cached or fresh based on input hash
- `useRecalculateProjection` is a mutation that forces POST (useful after client edits)
- 5-minute staleTime since projection data is expensive to compute
- Both functions return `ProjectionResponse` which includes `cached` boolean
  </action>
  <verify>
Run `npx tsc --noEmit` - should compile without errors.
Check file exists: `ls lib/hooks/use-projection.ts`
Check exports: `grep "export function" lib/hooks/use-projection.ts` shows both hooks.
  </verify>
  <done>
useProjection and useRecalculateProjection hooks created following TanStack Query patterns.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm ls recharts react-is react-countup` shows all three installed
2. `npx tsc --noEmit` passes with no errors
3. `lib/calculations/transforms.ts` exports ChartDataPoint, SummaryMetrics, transformToChartData, extractSummaryMetrics, formatCurrency, formatAxisValue
4. `lib/hooks/use-projection.ts` exports useProjection and useRecalculateProjection
5. `npm run build` completes successfully
</verification>

<success_criteria>
- recharts, react-is, react-countup installed in package.json
- Transform functions handle Projection type from Phase 04
- Formatting functions handle cents-to-dollars conversion
- Query hook follows existing TanStack Query patterns
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-results-summary-display/05-01-SUMMARY.md`
</output>
